The collections module in Python provides specialized container data types, which can be used to implement efficient and more readable
solutions than traditional data structures like lists, dictionaries, and tuples. Below are some key container data types from the 
collections module, along with simple examples:

1. namedtuple: Immutable, memory-efficient tuples with named fields
A namedtuple is a tuple subclass that allows we to access fields by name instead of position.

Feature			tuple					namedtuple
-------			-----					----------
Definition		An immutable sequence of elements.	A subclass of tuple with named fields for readability.
Access Elements		Accessed by index (e.g., t[0]).		Accessed by name (e.g., nt.field1) or index.
Readability		Less readable for multiple values.	More readable due to named fields.
Mutability		Immutable.				Immutable.
Use Case		Use when position is sufficient.	Use when names improve clarity or meaning.

Immutability: Like regular tuples, namedtuple objects are immutable, meaning their values cannot be changed after creation.
Memory Efficiency: Uses less memory compared to regular classes.
Code Simplicity: Avoids the need to define a full class manually.

Example tuple:
# Create a tuple
student = ("virat", 20, "mahi")

# Access by index
print(student[0])  # Output: virat
print(student[1])  # Output: 20
print(student[2])  # Output: mahi
-----------------------------
Example namedtuple:

from collections import namedtuple

# Create a namedtuple
Student = namedtuple("Student", ["name", "age", "grade"]) 
student = Student(name="messi", age=20, grade="A")

# Access by name or index
print(student.name)  # Output: messi
print(student.age)   # Output: 20
print(student.grade) # Output: A
print(student[0])    # Output: messi (index works too)

namedtuple from collections:

A namedtuple is a factory function in the collections module that creates a special subclass of tuple.
This subclass allows we to create tuples where each element is accessible by a name (attribute) instead of only by its index position.

namedtuple("TypeName", ["field1", "field2", ...])
"TypeName": This is the name of the resulting class (Student in this case).
["field1", "field2", ...]: A list of field names that define the structure of the tuple.

Creating the Student namedtuple class
Student = namedtuple("Student", ["name", "age", "grade"])

This creates a new class called Student with fields name, age, and grade.
Each field is given a name, making it easier to refer to specific values.

Creating an instance of Student
student = Student(name="messi", age=20, grade="A")

This line creates an object student of the Student namedtuple class.
The name is set to "Alice", age to 20, and grade to "A".
The resulting object behaves like a tuple but allows access to elements using field names.

Equivalent tuple: student = ("messi", 20, "A")

Accessing attributes
print(student.name)

student.name: Accesses the value of the name field from the student object. The value is "Alice".
Unlike regular tuples, we don’t need to remember the index (e.g., student[0]). Instead, we use the descriptive field name (name) for
readability.

Similarly
print(student.age)   # Output: 20
print(student.grade) # Output: A

The attributes of the Student namedtuple are: name, age, grade

Use tuple when element positions are clear and fixed.
Use namedtuple when naming fields improves clarity and we want to preserve immutability.

Queue
Definition: A linear data structure that follows the FIFO (First-In-First-Out) principle. Items are added at the rear and removed 
from the front. 
operations: - Enqueue (add) at the rear
- Dequeue (remove) from the front
flexibility: Limited to one end for insertion and another for removal.
use cases: Useful for tasks like process scheduling, request queues, etc.
module in python: Basic queues can be implemented using list or queue.Queue.

from queue import Queue

# Create a queue
q = Queue()

# Add elements to the queue
q.put(1)
q.put(2)
q.put(3)

# Remove elements (FIFO)
print(q.get())  # Output: 1
print(q.get())  # Output: 2

2. Deque (Double-Ended Queue)
deque is optimized for fast appends and pops from both ends of the sequence.

Definition: A generalized queue that allows insertion and removal of items from both ends (front and rear).
operations: - Add/remove at both ends (front and rear): append, appendleft, pop, popleft
flexibility: More flexible as it supports operations on both ends.
use cases: Useful for more complex scenarios like sliding windows, undo mechanisms, and double-ended operations.
module in python: Implemented using collections.deque, which is highly optimized for performance.

from collections import deque

# Create a deque
dq = deque()

# Add elements at both ends
dq.append(1)       # Add to the right
dq.appendleft(2)   # Add to the left

# Remove elements from both ends
print(dq.pop())       # Output: 1 (remove from right)
print(dq.popleft())   # Output: 2 (remove from left)

Feature		Queue				Deque
-------		-----				-----
Access		First-In, First-Out (FIFO)	Both ends (Double-ended)
Operations	enqueue, dequeue		append, appendleft, pop, popleft
Flexibility	Restricted to one end		Flexible at both ends
Library		queue.Queue			collections.deque


3. Counter: Counts hashable objects
Counter is a dictionary subclass used to count occurrences of elements.

Example:
from collections import Counter

# Count occurrences of characters in a string
char_count = Counter("hello python welcome to sai's world")

# Print counts
print(char_count)  # Output: Counter({'o': 5, ' ': 5, 'l': 4, 'e': 3, 'h': 2, 't': 2, 'w': 2, 's': 2, 'p': 1, 'y': 1, 'n': 1, 'c': 1, 'm': 1, 'a': 1, 'i': 1, "'": 1, 'r': 1, 'd': 1})
4

# Access specific counts
print(char_count['l'])  # Output: 4

4. OrderedDict: Dictionary that remembers insertion order
In Python 3.7+, normal dictionaries preserve order, but OrderedDict is useful for older versions or for additional methods.

from collections import OrderedDict

# Create an OrderedDict
od = OrderedDict()

# Add key-value pairs
od['name'] = 'sai'
od['age'] = 34
od['grade'] = 'A'

# Print the ordered dictionary
print(od)  # Output: OrderedDict([('name', 'sai'), ('age', 34), ('grade', 'A')])

5. defaultdict: Dictionary with default values
defaultdict allows we to define a default value for keys that are not yet in the dictionary.

from collections import defaultdict

# Create a defaultdict with a default type of list
dd = defaultdict(list)

# Add items
dd['cricket_bat'].append('english willow')
dd['cricket_bat'].append('kashmir willow')
dd['cricket_ball'].append('leather red')

# Access items
print(dd)  # Output: defaultdict(<class 'list'>, {'cricket_bat': ['english willow', 'kashmir willow'], 'cricket_ball': ['leather red']})

# Access a non-existing key (returns default list)
print(dd['cricket_bat'])  # Output: ['english willow', 'kashmir willow']

Feature			dict					Counter				OrderedDict			defaultdict
-------			----					-------				-----------			------------
Purpose			General key-value storage		Counts occurrences of items	Remembers insertion order	Provides default values for missing keys
Order Preservation	Yes (from Python 3.7+)			No				Yes				Yes
Default Values		None (KeyError for missing keys)	Default is 0 for counting	None				User-specified (e.g., list, int)
Special Features	Standard dictionary functionality	Automatic counting of elements	Preserves order of insertion	Automatically handles missing keys
Library			Built-in				collections.Counter		collections.OrderedDict		collections.defaultdict

Django Context
In a Django project, we might use these containers to manage data effectively. For example:

from collections import Counter
from django.http import JsonResponse

def word_count_view(request):
    text = "Django makes web development easy and efficient"
    word_count = Counter(text.split())
    return JsonResponse(word_count)

Tkinter GUI applications

Tkinter is a standard Python library for creating GUI (Graphical User Interface) applications. It provides a wide range of tools and widgets to build user-friendly interfaces.

Here’s a step-by-step guide to understand the basics of Tkinter with code examples for simple GUI applications:

1. Creating a Basic Tkinter Window
import tkinter as tk

# Create the main window
root = tk.Tk()

# Set window title and size
root.title("sai's tkinter test Window")
root.geometry("400x300")

# Run the application
root.mainloop()

2. Adding Widgets
Example: Adding a Label, Button, and Entry Field


Tkinter is a standard Python library for creating GUI (Graphical User Interface) applications. It provides a wide range of tools and 
widgets to build user-friendly interfaces.

Here’s a step-by-step guide to understand the basics of Tkinter with code examples for simple GUI applications:

1. Creating a Basic Tkinter Window
import tkinter as tk

# Create the main window
root = tk.Tk()

# Set window title and size
root.title("Basic Tkinter Window")
root.geometry("400x300")

# Run the application
root.mainloop()
2. Adding Widgets
Example: Adding a Label, Button, and Entry Field

import tkinter as tk

# Create the main window
root = tk.Tk()
root.title("Basic Widgets Example")
root.geometry("300x200")

# Add a label
label = tk.Label(root, text="hey sai Enter our name:")
label.pack(pady=10)

# Add an entry field
entry = tk.Entry(root)
entry.pack(pady=10)

# Add a button
def on_button_click():
    name = entry.get()
    label.config(text=f"Hello, {name}!")

button = tk.Button(root, text="Submit", command=on_button_click)
button.pack(pady=10)

# Run the application
root.mainloop()

3. Building a Simple Calculator

import tkinter as tk

# Create the main window
root = tk.Tk()
root.title("Simple Calculator")

# Entry widget for input
entry = tk.Entry(root, width=20, font=("Arial", 18), justify="right")
entry.grid(row=0, column=0, columnspan=4)

# Button click event
def button_click(number):
    current = entry.get()
    entry.delete(0, tk.END)
    entry.insert(0, current + str(number))

def clear():
    entry.delete(0, tk.END)

def calculate():
    try:
        result = eval(entry.get())
        entry.delete(0, tk.END)
        entry.insert(0, str(result))
    except:
        entry.delete(0, tk.END)
        entry.insert(0, "Error")

# Add buttons
buttons = [
    ('7', 1, 0), ('8', 1, 1), ('9', 1, 2), ('/', 1, 3),
    ('4', 2, 0), ('5', 2, 1), ('6', 2, 2), ('*', 2, 3),
    ('1', 3, 0), ('2', 3, 1), ('3', 3, 2), ('-', 3, 3),
    ('C', 4, 0), ('0', 4, 1), ('=', 4, 2), ('+', 4, 3),
]

for (text, row, col) in buttons:
    if text == "=":
        btn = tk.Button(root, text=text, width=5, height=2, command=calculate)
    elif text == "C":
        btn = tk.Button(root, text=text, width=5, height=2, command=clear)
    else:
        btn = tk.Button(root, text=text, width=5, height=2, command=lambda t=text: button_click(t))
    btn.grid(row=row, column=col, padx=5, pady=5)

# Run the application
root.mainloop()

4. A Simple Login Form

import tkinter as tk
from tkinter import messagebox

# Create the main window
root = tk.Tk()
root.title("Login Form")
root.geometry("300x200")

# Add labels and entry fields
tk.Label(root, text="Username").pack(pady=5)
username = tk.Entry(root)
username.pack(pady=5)

tk.Label(root, text="Password").pack(pady=5)
password = tk.Entry(root, show="*")
password.pack(pady=5)

# Login button action
def login():
    if username.get() == "admin" and password.get() == "password":
        messagebox.showinfo("Login Successful", "Welcome!")
    else:
        messagebox.showerror("Login Failed", "Invalid credentials")

tk.Button(root, text="Login", command=login).pack(pady=10)

# Run the application
root.mainloop()

A Simple To-Do List Application

import tkinter as tk

# Create the main window
root = tk.Tk()
root.title("To-Do List")
root.geometry("400x300")

# Add a listbox
tasks = tk.Listbox(root, width=50, height=10)
tasks.pack(pady=20)

# Add entry widget
task_entry = tk.Entry(root, width=40)
task_entry.pack()

# Add task
def add_task():
    task = task_entry.get()
    if task:
        tasks.insert(tk.END, task)
        task_entry.delete(0, tk.END)

# Remove task
def remove_task():
    selected_task = tasks.curselection()
    if selected_task:
        tasks.delete(selected_task)

# Buttons
add_button = tk.Button(root, text="Add Task", command=add_task)
add_button.pack(pady=5)

remove_button = tk.Button(root, text="Remove Task", command=remove_task)
remove_button.pack(pady=5)

# Run the application
root.mainloop()


Requests-HTTP requests

The Python requests library is a powerful and user-friendly module for sending HTTP requests. It simplifies interactions with web 
servers and APIs. Here's an overview and examples of common HTTP request methods: 

1. Installing the requests Library
To use the requests library, we need to install it:
pip install requests

2. Making HTTP Requests
Here are examples of basic HTTP request methods (GET, POST, etc.).

a) GET Request
Used to retrieve data from a server.


The Python requests library is a powerful and user-friendly module for sending HTTP requests. It simplifies interactions with web servers and APIs. Here's an overview and examples of common HTTP request methods:

1. Installing the requests Library
To use the requests library, we need to install it:
pip install requests
2. Making HTTP Requests
Here are examples of basic HTTP request methods (GET, POST, etc.).

a) GET Request
Used to retrieve data from a server.

import requests

# Send a GET request
response = requests.get("https://jsonplaceholder.typicode.com/posts/1")

# Print response content
if response.status_code == 200:
    print("Response JSON:", response.json())
else:
    print("Failed to retrieve data. Status code:", response.status_code)

b) POST Request
Used to send data to a server (e.g., submitting form data).
import requests

# Data to send
data = {
    "title": "foo",
    "body": "bar",
    "userId": 1
}

# Send a POST request
response = requests.post("https://jsonplaceholder.typicode.com/posts", json=data)

# Print response content
if response.status_code == 201:
    print("Post created:", response.json())
else:
    print("Failed to create post. Status code:", response.status_code)

This will not include the data we posted earlier. Instead, it will return the default dataset provided by the API.

will not find our custom data in the https://jsonplaceholder.typicode.com/posts endpoint. Here's why:

How JSONPlaceholder Works
JSONPlaceholder is a mock API that simulates creating, updating, or deleting resources but does not persist data.
When we send a POST request, it generates a fake response, including a new id, but does not store our data on the server.
The GET request to https://jsonplaceholder.typicode.com/posts will return the default, pre-existing mock data provided by 
JSONPlaceholder, not the data we submitted in our POST request.

Why Doesn't JSONPlaceholder Store Data?
JSONPlaceholder is designed for testing purposes, so:

It does not have a persistent database.
Each request is independent, and no data is stored between requests.

If we Want Persistent Data:
If we want our data to be stored and retrievable:

Use a real backend server like:
Django (with a database like SQLite or PostgreSQL).
Flask with a database.
Node.js with MongoDB.
Use a cloud-based REST API service like:
Firebase Realtime Database.
AWS API Gateway with Lambda and DynamoDB.

c) PUT Request
Used to update data on a server.


import requests

# Data to update
data = {
    "id": 1,
    "title": "sai",
    "body": "sadist",
    "userId": 1
}

# Send a PUT request
response = requests.put("https://jsonplaceholder.typicode.com/posts/1", json=data)

# Print response content
if response.status_code == 200:
    print("Post updated:", response.json())
else:
    print("Failed to update post. Status code:", response.status_code)

d) DELETE Request
Used to delete data from a server

import requests

# Send a DELETE request
response = requests.delete("https://jsonplaceholder.typicode.com/posts/1")

# Print response status
if response.status_code == 200:
    print("Post deleted successfully")
else:
    print("Failed to delete post. Status code:", response.status_code)


5. A Real-World Example: Consuming a Weather API
import requests

# Open-Meteo API URL
api_url = "https://api.open-meteo.com/v1/forecast"

# City to fetch the weather for
latitude = 16.3067  # Latitude for London
longitude = 80.4365  # Longitude for London

# Send a GET request
response = requests.get(api_url, params={"latitude": latitude, "longitude": longitude, "current_weather": "true"})

if response.status_code == 200:
    data = response.json()
    print(f"Weather in London: {data['current_weather']['weathercode']}")
    print(f"Temperature: {data['current_weather']['temperature']}°C")
else:
    print("Failed to fetch weather data. Status code:", response.status_code)


BeautifulSoup4 is a Python library used for web scraping purposes to extract data from HTML and XML files. It provides methods to 
parse HTML content and navigate the DOM (Document Object Model) tree. Here's an overview of how to use BeautifulSoup4 for web 
scraping:

1. Installing Required Libraries
we need to install both beautifulsoup4 and requests libraries:

pip install beautifulsoup4 requests

d an HTTP request to fetch the webpage and then parse the HTML content.


import requests
from bs4 import BeautifulSoup

# Fetch the webpage
url = "https://example.com"
response = requests.get(url)

# Check if the request was successful (status code 200)
if response.status_code == 200:
    # Parse the HTML content with BeautifulSoup
    soup = BeautifulSoup(response.content, "html.parser")

    # Print the parsed HTML (pretty format)
    print(soup.prettify())
else:
    print(f"Failed to retrieve the webpage. Status code: {response.status_code}")

3. Extracting Data Using BeautifulSoup
a) Finding a Specific Element by Tag Name
we can use methods like find() and find_all() to search for tags.

import requests
from bs4 import BeautifulSoup

# URL of the webpage to scrape
url = "https://example.com"

# Fetch the HTML content of the webpage
response = requests.get(url)

# Check if the request was successful
if response.status_code == 200:
    # Parse the HTML content with BeautifulSoup
    soup = BeautifulSoup(response.content, "html.parser")

    # Find the first <h1> tag
    h1_tag = soup.find("h1")
    if h1_tag:
        print("First <h1> tag:", h1_tag.text)
    else:
        print("No <h1> tag found.")

    # Find all <p> tags
    p_tags = soup.find_all("p")
    if p_tags:
        print("Paragraph tags:")
        for p in p_tags:
            print(p.text.strip())
    else:
        print("No <p> tags found.")
else:
    print(f"Failed to retrieve the webpage. Status code: {response.status_code}")

b) Accessing Attributes of an HTML Tag
To access the attributes of an HTML element (e.g., href in anchor tags), we can use the get() method.

import requests
from bs4 import BeautifulSoup

# URL to scrape
url = "https://example.com"

# Fetch the HTML content of the webpage
response = requests.get(url)

# Check if the request was successful
if response.status_code == 200:
    # Parse the HTML content using BeautifulSoup
    soup = BeautifulSoup(response.content, "html.parser")
    
    # Find the first <a> tag and print the href attribute
    a_tag = soup.find("a")
    if a_tag and "href" in a_tag.attrs:
        print("First <a> tag href:", a_tag["href"])
    else:
        print("No <a> tag found or it does not have an href attribute.")
    
    # Find all <a> tags and print their href attributes
    links = soup.find_all("a")
    print("\nAll <a> tag hrefs:")
    for link in links:
        href = link.get("href")  # Use .get() to avoid KeyError if href is missing
        if href:
            print(href)
else:
    print(f"Failed to fetch the webpage. Status code: {response.status_code}")

4. Navigating the DOM
we can navigate the DOM tree using methods like .parent, .children, .next_sibling, .previous_sibling, etc.


import requests
from bs4 import BeautifulSoup

# Sample HTML for demonstration (we can replace this with a real URL)
html_content = """
<html>
<head><title>Sample Page</title></head>
<body>
    <div id="main">
        <p>First paragraph inside the div.</p>
        <p>Second paragraph inside the div.</p>
        <span>Additional content in the div.</span>
    </div>
</body>
</html>
"""

# Parse the HTML content with BeautifulSoup
soup = BeautifulSoup(html_content, "html.parser")

# Find a <div> and navigate to its parent tag
div_tag = soup.find("div")
if div_tag:
    print("Parent of <div> tag:")
    print(div_tag.parent)

    # Find a <div> and print its children
    print("\nChildren of <div> tag:")
    for child in div_tag.children:
        print(child)
else:
    print("No <div> tag found in the HTML.")

5. Filtering and Searching for Specific Data
we can filter the search results using class_ or id attributes to narrow down the tags we're interested in.
a) Search by Class Name
b) Search by ID

import requests
from bs4 import BeautifulSoup

# URL of the webpage to scrape
url = "https://example.com"

# Fetch the webpage content
response = requests.get(url)

# Check if the request was successful
if response.status_code == 200:
    # Parse the HTML content
    soup = BeautifulSoup(response.content, "html.parser")

    # Find all elements with a specific class
    class_elements = soup.find_all(class_="example-class")
    for element in class_elements:
        print(element.text)

    # Find an element with a specific ID
    element_by_id = soup.find(id="example-id")
    if element_by_id:
        print(element_by_id.text)
    else:
        print("Element with the specified ID was not found.")
else:
    print(f"Failed to fetch the webpage. Status code: {response.status_code}")

6. Example: Scraping Data from a Web Page
Let's say we want to scrape the titles of blog posts from a website.

import requests
from bs4 import BeautifulSoup

# URL of the blog
url = "https://example-blog.com"

# Fetch the HTML content
response = requests.get(url)
soup = BeautifulSoup(response.content, "html.parser")

# Find all blog post titles (assuming they are inside <h2> tags with class 'post-title')
titles = soup.find_all("h2", class_="post-title")

# Print each title
for title in titles:
    print(title.text.strip())

7. Handling Pagination in Web Scraping
For scraping multiple pages (e.g., pagination), we can loop through the pages by modifying the URL based on the page number.

import requests
from bs4 import BeautifulSoup

# Base URL for pagination
base_url = "https://example-blog.com/page/"

# Scrape the first 5 pages
for page_num in range(1, 6):
    url = f"{base_url}{page_num}"
    response = requests.get(url)
    
    if response.status_code == 200:
        soup = BeautifulSoup(response.content, "html.parser")
        titles = soup.find_all("h2", class_="post-title")
        
        # Print titles for the current page
        for title in titles:
            print(title.text.strip())
    else:
        print(f"Failed to retrieve page {page_num}. Status code: {response.status_code}")

Handling Exceptions and Errors
When working with web scraping, it’s important to handle exceptions (e.g., network errors, missing elements) gracefully.

import requests
from bs4 import BeautifulSoup

try:
    # Make the request and parse the content
    response = requests.get("https://example.com")
    response.raise_for_status()  # Raise an exception for HTTP errors

    # Parse the HTML content with BeautifulSoup
    soup = BeautifulSoup(response.content, "html.parser")

    # Example of extracting data
    title = soup.find("title").text
    print(f"Page Title: {title}")

except requests.exceptions.RequestException as e:
    # Handles HTTP and connection-related errors
    print(f"Request error: {e}")
except Exception as e:
    # Handles any other exceptions
    print(f"An error occurred: {e}")
else:
    # Executed if no exceptions occur
    print("Webpage fetched and parsed successfully.")

Respecting Website's Robots.txt and Terms of Service
Before scraping a website, always check its robots.txt file to ensure we are allowed to scrape it. For example, we can add a delay 
between requests or avoid scraping sensitive information.

import time
import requests
from bs4 import BeautifulSoup

# Base URL for scraping
base_url = "https://example-blog.com/page/"

# Number of pages to scrape
num_pages = 5

# Loop through the pages
for page_num in range(1, num_pages + 1):
    url = f"{base_url}{page_num}"
    print(f"Scraping page {page_num}: {url}")
    
    try:
        # Make the request to fetch the page
        response = requests.get(url)
        response.raise_for_status()  # Raise an exception for HTTP errors
        
        # Parse the HTML content with BeautifulSoup
        soup = BeautifulSoup(response.content, "html.parser")
        
        # Extract specific data (e.g., blog post titles)
        titles = soup.find_all("h2", class_="post-title")
        for title in titles:
            print(title.text.strip())
        
    except requests.exceptions.RequestException as e:
        print(f"Request failed for {url}: {e}")
    except Exception as e:
        print(f"An error occurred: {e}")
    
    # Add a delay of 1 second between requests
    time.sleep(1)

print("Scraping completed!")

Scrapy is an open-source and robust web scraping framework in Python. It is designed for large-scale scraping projects and provides 
advanced features such as handling asynchronous requests, managing data pipelines, and working with spiders for scraping multiple 
pages or websites.

Here's a step-by-step guide to get started with Scrapy:

1. Installing Scrapy
To install Scrapy, use pip:
pip install scrapy

2. Creating a Scrapy Project
we can create a new Scrapy project by running:
scrapy startproject scr_proj

3. Creating a Spider
A spider is a class that defines how to scrape a website, including the URLs to scrape and how to extract the data.

Example: Spider to Scrape Quotes
Navigate to the spiders directory and create a new spider file (e.g., quotes_spider.py).

import scrapy

class QuotesSpider(scrapy.Spider):
    name = "quotes"  # Unique spider name
    start_urls = [
        "http://quotes.toscrape.com"
    ]

    def parse(self, response):
        # Extract quotes and authors
        for quote in response.css("div.quote"):
            yield {
                "text": quote.css("span.text::text").get(),
                "author": quote.css("small.author::text").get(),
                "tags": quote.css("div.tags a.tag::text").getall(),
            }

        # Follow the "Next" page link
        next_page = response.css("li.next a::attr(href)").get()
        if next_page is not None:
            yield response.follow(next_page, self.parse)


C:\Users\abc\Desktop\django\scr_proj>tree /f
Folder PATH listing
Volume serial number is 18B1-77A2
C:.
│   scrapy.cfg
│
└───scr_proj
    │   items.py
    │   middlewares.py
    │   pipelines.py
    │   quotes.csv
    │   quotes.json
    │   settings.py
    │   __init__.py
    │
    ├───spiders
    │   │   quotes_spider.py
    │   │   __init__.py
    │   │
    │   └───__pycache__
    │           quotes_spider.cpython-312.pyc
    │           quotes_spyder.cpython-312.pyc
    │           __init__.cpython-312.pyc
    │
    └───__pycache__
            settings.cpython-312.pyc
            __init__.cpython-312.pyc


4. Running the Spider
To run our spider, use the following command:
scrapy crawl quotes

5. Saving Scraped Data
we can save the scraped data to a file (e.g., JSON, CSV) using the following command:
scrapy crawl quotes -o quotes.json

Example: Scraping E-Commerce Data

import scrapy

class ProductsSpider(scrapy.Spider):
    name = "products"
    start_urls = ["https://example-ecommerce.com/products"]

    def parse(self, response):
        for product in response.css("div.product"):
            yield {
                "name": product.css("h2.product-name::text").get(),
                "price": product.css("span.price::text").get(),
                "availability": product.css("p.availability::text").get(),
            }

        next_page = response.css("a.next::attr(href)").get()
        if next_page is not None:
            yield response.follow(next_page, self.parse)


Zappa is a Python library that simplifies the process of deploying Python web applications (especially Flask, Django, and other WSGI 
applications) to AWS Lambda and API Gateway. It helps we run web applications in a serverless environment, which can be highly 
cost-effective and scalable, especially for applications with variable traffic.

Here’s a step-by-step guide to help we get started with Zappa:

1. Installing Zappa
To use Zappa, we need to install it with pip:
pip install zappa

2. Setting Up AWS Credentials
Before we can use Zappa to deploy applications, we need to set up our AWS credentials. Zappa will use these credentials to interact with AWS services like Lambda and API Gateway.

we can set up the credentials using the AWS CLI:
aws configure

This will prompt we to enter our AWS access key, secret access key, region, and output format. Alternatively, we can manually set up the credentials in the ~/.aws/credentials file.

3. Creating a Python Web Application
Zappa works best with web frameworks like Flask or Django. Let's start by creating a basic Flask app.

Example: Basic Flask Application (app.py)
from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!'

if __name__ == '__main__':
    app.run()

4. Initializing Zappa
Once we have our application ready, initialize Zappa in our project folder. This will generate a zappa_settings.json configuration file.

In our terminal, run:
zappa init

Zappa will ask we a series of questions to configure our deployment:

What is the name of our app?
Which Python version do we want to use?
Which AWS region do we want to deploy to?
Do we want to create a new IAM role?
After answering these questions, Zappa will create a zappa_settings.json file, which looks something like this:

{
  "production": {
    "app_function": "app.app",
    "aws_region": "us-east-1",
    "profile_name": "default",
    "project_name": "my-flask-app",
    "runtime": "python3.8",
    "s3_bucket": "zappa-my-flask-app"
  }
}

app_function: Points to our Flask application (i.e., "app.app" means the Flask instance is in the app.py file).
aws_region: The AWS region where our app will be deployed.
profile_name: our AWS CLI profile name (usually default).
project_name: The name of our project.
runtime: The Python runtime (e.g., python3.8).
s3_bucket: A unique S3 bucket where Zappa will upload our app’s package for deployment.

5. Deploying the Application
Now, we can deploy our application to AWS Lambda using Zappa. To do this, run the following command:

zappa deploy production

Zappa will:

Package our app.
Upload it to AWS Lambda.
Set up an API Gateway endpoint.
Deploy everything automatically.
Once the deployment is complete, Zappa will output a URL for our app, which we can visit in the browser.

6. Updating our Application
If we make changes to our app and want to deploy the updates, we can use the zappa update command:

zappa update production

This will redeploy the updated version of our app without affecting any configuration settings.

CherryPy
CherryPy is a minimalist, object-oriented web framework for Python that provides the basics needed to build web applications, and it can be used to create small, simple apps as well as large-scale web applications. It has a simple and extensible interface for handling HTTP requests and responses, and it allows Python developers to focus on application logic instead of dealing with the intricacies of low-level HTTP handling.

Here’s an overview of CherryPy, including installation, basic usage, and an example:

Key Features of CherryPy
Minimalist: CherryPy provides the basic tools needed to build web applications, without adding unnecessary complexity.
Object-Oriented: CherryPy treats everything as an object. we define classes to handle HTTP requests and map them to URLs.
WSGI-Compliant: CherryPy is fully compliant with the WSGI (Web Server Gateway Interface) standard, meaning we can deploy it using any WSGI-compatible server.
Built-in HTTP Server: CherryPy comes with a built-in HTTP server, but it can also be used with other WSGI servers like Gunicorn or uWSGI.
Threaded: CherryPy supports multi-threading, allowing it to handle multiple requests simultaneously.
Extensible: It supports middleware and allows customization of the request/response lifecycle.

1. Installing CherryPy
To install CherryPy, we can use pip:
pip install cherrypy


CherryPy is a minimalist, object-oriented web framework for Python that provides the basics needed to build web applications, and it can be used to create small, simple apps as well as large-scale web applications. It has a simple and extensible interface for handling HTTP requests and responses, and it allows Python developers to focus on application logic instead of dealing with the intricacies of low-level HTTP handling.

Here’s an overview of CherryPy, including installation, basic usage, and an example:

Key Features of CherryPy
Minimalist: CherryPy provides the basic tools needed to build web applications, without adding unnecessary complexity.
Object-Oriented: CherryPy treats everything as an object. we define classes to handle HTTP requests and map them to URLs.
WSGI-Compliant: CherryPy is fully compliant with the WSGI (Web Server Gateway Interface) standard, meaning we can deploy it using any WSGI-compatible server.
Built-in HTTP Server: CherryPy comes with a built-in HTTP server, but it can also be used with other WSGI servers like Gunicorn or uWSGI.
Threaded: CherryPy supports multi-threading, allowing it to handle multiple requests simultaneously.
Extensible: It supports middleware and allows customization of the request/response lifecycle.
1. Installing CherryPy
To install CherryPy, we can use pip:
pip install cherrypy

2. Basic CherryPy Application
CherryPy makes it easy to define simple web applications by creating Python classes and associating them with URL paths. Each class method that corresponds to a URL endpoint becomes an HTTP request handler.

Example of a Basic CherryPy Application:
import cherrypy

class HelloWorld:
    @cherrypy.expose
    def index(self):
        return "Hello, World!"

if __name__ == '__main__':
    cherrypy.quickstart(HelloWorld())

The @cherrypy.expose decorator exposes the index method as a handler for the root URL (/).
The cherrypy.quickstart() function runs the web server and serves the application.
When we run this application and navigate to http://127.0.0.1:8080 in our browser, we’ll see the message "Hello, World!".

3. Advanced CherryPy Application with Multiple Routes
we can define multiple routes by creating different methods in the same class or using additional classes.

Example: A More Complex Application

import cherrypy

class MyApp:
    @cherrypy.expose
    def index(self):
        return "Welcome to My Web App!"

    @cherrypy.expose
    def about(self):
        return "This is the about page."

    @cherrypy.expose
    def hello(self, name="World"):
        return f"Hello, {name}!"

if __name__ == '__main__':
    cherrypy.quickstart(MyApp())

URL Paths:
/ — The index method is exposed and returns the main page.
/about — The about method is exposed and returns an about page.
/hello/{name} — The hello method returns a personalized greeting, where {name} is passed as a query parameter.
Example URLs:

http://127.0.0.1:8080/ — Displays "Welcome to My Web App!"
http://127.0.0.1:8080/about — Displays "This is the about page."
http://127.0.0.1:8080/hello/virat — Displays "Hello, Virat!"

4. Configuring CherryPy
CherryPy allows we to configure the web server and application behavior using a configuration file or directly in code.

Example: Configuration using a Python Dictionary

import cherrypy

class MyApp:
    @cherrypy.expose
    def index(self):
        return "Welcome to My Web App!"

if __name__ == '__main__':
    cherrypy.config.update({
        'server.socket_port': 8080,  # Port to run the server
        'server.socket_host': '0.0.0.0',  # Listen on all interfaces
    })
    cherrypy.quickstart(MyApp())

This will run the application on port 8080 and make it accessible from any IP address (useful for production).

import cherrypy

class MyApp:
    @cherrypy.expose
    def index(self):
        return "Welcome to My Web App! Static files are served from the /static URL."

if __name__ == '__main__':
    # Mount the application
    cherrypy.tree.mount(
        MyApp(),
        "/",
        {
            "/static": {
                "tools.staticdir.on": True,
                "tools.staticdir.dir": "static",  # Path to our static files folder
            }
        }
    )

    # Start the CherryPy server
    cherrypy.config.update({
        "server.socket_host": "127.0.0.1",  # Bind to localhost
        "server.socket_port": 8080,        # Run on port 8080
    })

    cherrypy.engine.start()
    cherrypy.engine.block()

Directory Structure
Make sure our project structure looks like this:

django/
│
├── test.py       # our CherryPy script
├── static/       # Directory for static files
│   ├── example.css
│   ├── script.js
│   ├── image.png

Accessing the Static Files
URL: http://localhost:8080/static/example.css
URL: http://localhost:8080/static/image.png

Handling HTTP Methods (GET, POST, PUT, DELETE)
import cherrypy

class MyApp:
    @cherrypy.expose
    def index(self):
        return '''
            <form method="post" action="/submit">
                Name: <input type="text" name="name" />
                <input type="submit" value="Submit" />
            </form>
        '''

    @cherrypy.expose
    def submit(self, name):
        return f"Hello, {name}!"

if __name__ == '__main__':
    cherrypy.quickstart(MyApp())

Running CherryPy in Production
Although CherryPy comes with its own built-in server, it is not recommended to use it for production. For production environments, we should deploy CherryPy behind a WSGI server like Gunicorn or uWSGI.

Running CherryPy with Gunicorn:
First, install Gunicorn:
pip install gunicorn

Then run our CherryPy app using Gunicorn:
gunicorn myapp:app

Disadvantages of CherryPy
Minimal Features: CherryPy does not come with built-in tools for database handling, form validation, or authentication. we must use external libraries or implement these features ourself.
Lesser Popularity: While CherryPy is powerful, it's less commonly used compared to frameworks like Flask or Django, so there’s a smaller community for support.
Not Ideal for All Use Cases: It might not be the best choice for very large applications, as more comprehensive frameworks like Django provide more out-of-the-box tools.

Web2Py


Web2Py is a Python-based full-stack web framework that focuses on simplicity and rapid application development. It comes with built-in
tools for web development, including an integrated development environment (IDE), database abstraction, and a web-based admin 
interface.

Key Features of Web2Py
Full-Stack Framework: Includes everything needed for web development: routing, database integration, templating, and more.
No Installation Required: Web2Py is self-contained, meaning it doesn’t need installation. we can simply run the provided executable.
Web-Based IDE: Includes an integrated web-based development environment for writing, debugging, and testing our application.
Database Abstraction: Comes with a powerful Database Abstraction Layer (DAL) that supports multiple databases (e.g., SQLite, PostgreSQL, MySQL).
Security First: Focuses on security with features like form validation, protection against SQL injection, cross-site scripting (XSS), and cross-site request forgery (CSRF).
Multi-Language Support: Built-in support for creating multilingual applications.
Backwards Compatibility: Web2Py maintains backward compatibility across versions.

Installation and Setup
we can download Web2Py from its official website (web2py.com) or install it via pip:

pip install web2py

× Getting requirements to build wheel did not run successfully.
│ exit code: 1
╰─> See above for output.

note: This error originates from a subprocess, and is likely not a problem with pip.

the web2py package is not installed via pip due to compatibility problems or missing dependencies. However, Web2Py is typically not installed via pip. Instead, it's downloaded and run as a standalone application.

Here’s how we can properly set up Web2Py:

Correct Way to Set Up Web2Py
Download Web2Py:

Go to the official Web2Py website: http://www.web2py.com/init/default/download.
Download the package for our operating system.
Extract Web2Py:

After downloading the package (usually a ZIP file), extract it to a desired folder (e.g., C:\Users\abc\Desktop\web2py).
Run Web2Py:

Navigate to the folder where we extracted Web2Py.
Run the web2py.py script using Python:
python web2py.py

web2py Web Framework
Created by Massimo Di Pierro, Copyright 2007-2025
3.0.11-stable+timestamp.2024.12.28.14.24.26
Database drivers available: sqlite3, imaplib, pymysql, pyodbc
WARNING:web2py:GUI not available because Tk library is not installed
choose a password:

please visit:
        http://127.0.0.1:8000/
use "taskkill /f /pid 7208" to shutdown the web2py server

If we're using Python 3.12 or later, we may need to use an earlier version of Python (e.g., 3.9 or 3.10), as Web2Py may not yet support the latest Python versions.

It seems Web2Py is running successfully! However, the warning about the GUI indicates that the Tkinter library is missing, which is used for Web2Py's graphical user interface (GUI). This is optional and does not affect the core functionality of Web2Py.

Steps to Complete the Setup:
Set Admin Password:

After we see the prompt choose a password:, enter a secure password. This will be used to access the Web2Py administrative interface.
Access the Admin Interface:

Once Web2Py starts, we can access the admin interface via a web browser at:
http://127.0.0.1:8000/

Optional: Fixing the Tkinter Warning
The warning about Tkinter is only relevant if we plan to use Web2Py's built-in GUI. To install Tkinter:

If we're using Python on Windows:

Tkinter is included with most Python installations. If it's missing, we may need to reinstall Python and ensure we select the "Tcl/Tk and IDLE" option during installation.

Creating a Web2Py Application
When we start Web2Py, it launches a web-based administrative interface that allows we to create and manage applications.

Basic Application Structure
Controllers: Python scripts that handle application logic.
Views: HTML templates with placeholders for dynamic content.
Models: Define database tables and logic.
Static: Static files like CSS, JavaScript, and images.
Modules: Python modules used in the app.

to shut down this server use the following command
taskkill /f /pid process_id

Bottle
Bottle is a lightweight and fast Python web framework that is perfect for building small web applications and APIs. It is a 
single-file framework with no dependencies other than Python's standard library, making it ideal for quick development and deployment.

Features of Bottle:
Lightweight and minimalistic.
Single-file framework (easy to manage).
Built-in HTTP development server.
Supports routing, templates, and request/response handling.
Compatible with WSGI servers.

Installation:
we can install Bottle using pip:
pip install bottle

from bottle import Bottle, run

# Create a Bottle app instance
app = Bottle()

# Define a route and its handler
@app.route('/')
def home():
    return "Welcome to Bottle Framework!"

# Run the app
if __name__ == "__main__":
    run(app, host='localhost', port=8080)


Visit http://localhost:8080 in our browser to see the message "Welcome to Bottle Framework!".

Adding Dynamic Routes:
from bottle import Bottle, run

# Create a Bottle app instance
app = Bottle()

# Define a route with a dynamic parameter
@app.route('/hello/<name>')
def hello(name):
    return f"Hello, {name.capitalize()}!"

# Run the app
if __name__ == "__main__":
    run(app, host='localhost', port=8080)


Usage:
Save the code in a file, e.g., test.py.
python test.py

http://localhost:8080/hello/sai
Output: Hello, sai!

Handling Forms and Query Parameters:
from bottle import Bottle, request, run

# Create a Bottle app instance
app = Bottle()

# GET request to display the form
@app.route('/greet', method='GET')
def greet_form():
    return '''
        <form action="/greet" method="post">
            Name: <input name="name" type="text" />
            <input value="Greet" type="submit" />
        </form>
    '''

# POST request to handle the form submission
@app.route('/greet', method='POST')
def greet_submit():
    name = request.forms.get('name')
    return f"Hello, {name.capitalize()}!"

# Run the Bottle app
if __name__ == "__main__":
    run(app, host='localhost', port=8080)

GET request displays the form.
POST request processes the form submission.

Steps to Run:
Save the file (e.g., test.py).

python test.py

Visit http://localhost:8080/greet in our browser.
On GET request: we'll see a form asking for our name.
On POST request: After submitting the form, we'll see a greeting with the name we entered.

Serving Static Files:

from bottle import Bottle, static_file, run

# Create a Bottle app instance
app = Bottle()

# Define the route to serve static files
@app.route('/static/<filename>')
def serve_static(filename):
    return static_file(filename, root='./static')

# Run the Bottle app
if __name__ == "__main__":
    run(app, host='localhost', port=8080)

project/
│
├── app.py          # The above script
├── static/         # Folder for static files
│   ├── style.css   # Example static file
│   ├── script.js   # Example static file
│   └── image.png   # Example static file


Start the application by running:
python app.py

Access a static file in our browser, e.g.:
http://localhost:8080/static/style.css

Using Templates:
Bottle has a built-in templating engine.

Template Example:
from bottle import Bottle, template, run

# Create a Bottle app instance
app = Bottle()

# Define a route with a dynamic segment
@app.route('/welcome/<name>')
def welcome(name):
    return template('<b>Welcome, {{name}}</b>!', name=name)

# Run the Bottle application
if __name__ == "__main__":
    run(app, host='localhost', port=8080)

http://localhost:8080/welcome/sai

A Simple API with Bottle:

from bottle import Bottle, run  # Import Bottle and run to create and start the app
import json  # Import json for JSON serialization

# Create a Bottle app instance
app = Bottle()

# Define a route that returns JSON data
@app.route('/api/data')
def api_data():
    data = {"name": "Bottle", "framework": "Python"}
    return json.dumps(data)

# Run the app
if __name__ == "__main__":
    run(app, host='localhost', port=8080)

Running Bottle with a WSGI Server (like Gunicorn):
we can use a WSGI server for production deployment:
gunicorn app:app

Here, app refers to our Bottle app instance.

Visiting http://localhost:8080/api/data will return JSON data: {"name": "Bottle", "framework": "Python"}.

Sample Experiments:
Write a Python GUI program to import Tkinter package and create a window. Set its title and add a label to the window. 

a simple Python GUI program that uses the Tkinter package to create a window, set its title, and add a label to it:

test.py

import tkinter as tk  # Import the Tkinter package

# Create the main window
root = tk.Tk()

# Set the window title
root.title("sai's GUI using Tkinter")

# Set the window size (optional)
root.geometry("400x200")  # Width x Height

# Add a label to the window
label = tk.Label(root, text="Welcome to my sadistic world!!!", font=("Arial", 16))
label.pack(pady=20)  # Add some padding to center the label vertically

# Run the application
root.mainloop()

Importing Tkinter: import tkinter as tk imports the library.
Creating the Window: tk.Tk() creates the main application window.
Setting Title: root.title("My First Tkinter GUI") sets the title of the window.
Adding a Label: tk.Label() creates a text label, and pack() positions it in the window.
Running the Application: root.mainloop() starts the Tkinter event loop to keep the window open

Output:
When we run this program:

A window titled "sai's GUI using Tkinter" will appear.
The text "Welcome to my sadistic world!!!" will be displayed in the center of the window

Write a Python program that designs a simple login form with labels and Entry widgets, arranging them in a grid using the Grid 
geometry manager. 

a Python program that creates a simple login form using Tkinter. The program uses the grid geometry manager to arrange the widgets in a grid layout:

test.py
import tkinter as tk

# Create the main window
root = tk.Tk()
root.title("Login Form")
root.geometry("300x200")

# Create Labels and Entry Widgets
tk.Label(root, text="Username:").grid(row=0, column=0, padx=10, pady=10, sticky="e")
username_entry = tk.Entry(root, width=25)
username_entry.grid(row=0, column=1, padx=10, pady=10)

tk.Label(root, text="Password:").grid(row=1, column=0, padx=10, pady=10, sticky="e")
password_entry = tk.Entry(root, width=25, show="*")
password_entry.grid(row=1, column=1, padx=10, pady=10)

# Define the Login Button Action
def login():
    username = username_entry.get()
    password = password_entry.get()
    print(f"Username: {username}")
    print(f"Password: {password}")

# Add Login Button
login_button = tk.Button(root, text="Login", command=login)
login_button.grid(row=2, column=0, columnspan=2, pady=20)

# Run the application
root.mainloop()

grid Geometry Manager:

grid(row, column) places each widget in a specific row and column of the grid.
padx and pady add horizontal and vertical padding.
sticky="e" aligns the widget to the right edge (east) of the grid cell.

Entry Widgets:
The username_entry and password_entry widgets allow users to input text.
show="*" masks the password input for the password_entry.

Login Button:
A button labeled "Login" is created, and its command property is linked to the login function.

Functionality:
When the Login button is clicked, the login function retrieves the entered username and password and prints them in the console.

Output:
When we run the program:

A login form with "Username" and "Password" labels, entry fields, and a "Login" button will appear.
Entering text and clicking the "Login" button prints the entered values in the console.

test.py
import tkinter as tk
from tkinter import messagebox

# Create the main window
root = tk.Tk()
root.title("Login Form")
root.geometry("300x200")

# Styling variables
LABEL_FONT = ("Arial", 12)
ENTRY_WIDTH = 25
BUTTON_FONT = ("Arial", 10)

# Create Labels and Entry Widgets
tk.Label(root, text="Username:", font=LABEL_FONT).grid(row=0, column=0, padx=10, pady=10, sticky="e")
username_entry = tk.Entry(root, width=ENTRY_WIDTH)
username_entry.grid(row=0, column=1, padx=10, pady=10)

tk.Label(root, text="Password:", font=LABEL_FONT).grid(row=1, column=0, padx=10, pady=10, sticky="e")
password_entry = tk.Entry(root, width=ENTRY_WIDTH, show="*")
password_entry.grid(row=1, column=1, padx=10, pady=10)

# Define the Login Button Action
def login():
    username = username_entry.get().strip()
    password = password_entry.get().strip()

    # Validation logic
    if not username or not password:
        messagebox.showerror("Error", "Both fields are required!")
    elif username == "avadokadu" and password == "nekenduku":
        messagebox.showinfo("Success", f"Welcome, {username}!")
    else:
        messagebox.showerror("Error", "Invalid credentials. Please try again.")

# Add Login Button
login_button = tk.Button(root, text="Login", font=BUTTON_FONT, command=login)
login_button.grid(row=2, column=0, columnspan=2, pady=20)

# Run the application
root.mainloop()

Write a program using BeautifulSoup4 library for web scraping for a given URL 
a Python program using the BeautifulSoup4 library for web scraping. This example demonstrates how to fetch and parse HTML content 
from a given URL:

import requests
from bs4 import BeautifulSoup

# Function to scrape a given URL
def scrape_website(url):
    try:
        # Fetch the content of the URL
        response = requests.get(url)
        response.raise_for_status()  # Check if the request was successful

        # Parse the HTML content
        soup = BeautifulSoup(response.text, 'html.parser')

        # Example: Extract and display the title of the page
        page_title = soup.title.string
        print(f"Page Title: {page_title}")

        # Example: Extract all links (anchor tags) from the page
        print("\nLinks found on the page:")
        for link in soup.find_all('a', href=True):
            print(link['href'])

    except requests.exceptions.RequestException as e:
        print(f"Error fetching URL: {e}")

# Main code
if __name__ == "__main__":
    # Replace with the URL we want to scrape
    url = "https://www.python.org/"
    scrape_website(url)

C:\Users\abc\Desktop\django>python test.py
Page Title: Welcome to Python.org

Output:
For the URL https://www.python.org/, the output might look like this:

Links found on the page:
#content
#python-network
/
https://www.python.org/psf/
https://docs.python.org
https://pypi.org/

Dependencies:

requests: Used to fetch the HTML content of the webpage.
BeautifulSoup: Parses the HTML content for easy extraction of data.
Steps:

Fetch the webpage content using requests.get(url).
Parse the content using BeautifulSoup(response.text, 'html.parser').
Extract specific data such as:
Page title: soup.title.string
All links (anchor tags): soup.find_all('a', href=True).

Error Handling:
The program includes basic error handling using requests.exceptions.RequestException to catch issues like invalid URLs or connection 
problems.
 
Develop a sample Hello World page using Flask framework
test.py
from flask import Flask

# Create a Flask app instance
app = Flask(__name__)

# Define a route for the root URL ('/')
@app.route('/')
def hello():
    return "Hello, World!"  # This will be displayed in the browser

# Run the app
if __name__ == "__main__":
    app.run(debug=True)

Creating a Flask App:
app = Flask(__name__): Initializes the Flask application. __name__ tells Flask to look for the application in the current module.

Route Handling:
@app.route('/'): Defines a route for the root URL (/). When someone visits the website, this route is executed.
def hello(): This function returns the text "Hello, World!" which is displayed in the web browser.

Running the App:
app.run(debug=True): Starts the development server. The debug=True flag ensures that any changes to the code are automatically 
reloaded in the server.

Running the Program:
Save the script as test.py.
Run the script in our terminal: python test.py

Output:
After running the script, open our web browser and navigate to http://127.0.0.1:5000/.
we should see the Hello, World! message displayed.

When we access http://127.0.0.1:5000/, the Flask app triggers the hello() function, which sends the string "Hello, World!" back to 
the browser.

Develop a sample web page using CherryPy / Web2Py / Bottle Framework
a sample web page using the Bottle Framework. This example will serve a simple "Hello, World!" page

test.py
from bottle import Bottle, run

# Create a Bottle app instance
app = Bottle()

# Define a route for the root URL ('/')
@app.route('/')
def home():
    return "<h1>Hello, World!</h1><p>Welcome to Bottle Framework</p>"

# Run the app
if __name__ == "__main__":
    run(app, host='localhost', port=8080, debug=True)


Creating the App:

app = Bottle() creates an instance of the Bottle application.
Defining a Route:

@app.route('/'): Specifies that the home() function will handle requests to the root URL (/).
The function home() returns a simple HTML response.
Running the App:

run(app, host='localhost', port=8080, debug=True) starts a local development server on http://localhost:8080

Running the Program:
Save the file as python test.py
Run the script in the terminal: python test.py

Output:
Open your web browser and navigate to: http://localhost:8080/.
we’ll see the following content:
Hello, World!
Welcome to Bottle Framework

Extending the Application:
add more routes and create a simple web page with navigation. Here’s an example:

test.py

from bottle import Bottle, run

# Create a Bottle app instance
app = Bottle()

# Define the Home route
@app.route('/')
def home():
    return "<h1>Home Page</h1><p>Welcome to the Bottle Framework!</p>"

# Define the About route
@app.route('/about')
def about():
    return "<h1>About Page</h1><p>This is a sample Bottle web application.</p>"

# Define the Contact route
@app.route('/contact')
def contact():
    return "<h1>Contact Page</h1><p>Contact us at support@example.com</p>"

# Run the app
if __name__ == "__main__":
    run(app, host='localhost', port=8080, debug=True)


Add these routes to the program, and now you can navigate to:
http://localhost:8080/about
http://localhost:8080/contact

Routes:

/: Home page.
/about: About page, displaying information about the application.
/contact: Contact page, showing contact details.
HTML Response:

Each route returns a simple HTML string for the respective page.
Running the App:

The app runs on http://localhost:8080/

CherryPy application
import cherrypy

class HelloWorld:
    @cherrypy.expose
    def index(self):
        return "<h1>Hello, World!</h1><p>Welcome to CherryPy Framework!</p>"

if __name__ == "__main__":
    cherrypy.quickstart(HelloWorld(), '/', config={
        'global': {
            'server.socket_host': '127.0.0.1',
            'server.socket_port': 8080,
        }
    })

Expose Methods: The @cherrypy.expose decorator makes the index() method accessible via HTTP.
Starting the Server: cherrypy.quickstart() runs the application.

CherryPy: Minimal and lightweight; good for small-scale apps.
Web2Py: Full-stack framework, ideal for larger applications with database support.


Aspect		CherryPy				Web2Py						Bottle
------		--------				------						-------
Type		Microframework				Full-stack framework				Microframework
Purpose		Lightweight, for building web services	Comprehensive, for full web applications	Lightweight, for small apps or APIs
Ease of Use	Easy, with built-in HTTP server		Moderate, has many features to learn		Very easy, minimal setup
File Structure	Flexible, no enforced structure		Enforces MVC structure				Flexible, single-file apps possible
Performance	High					Moderate to high				High
Features	Built-in HTTP server, WSGI support	Built-in web server, admin panel, database	Minimal, WSGI support, small size
Dependencies	Few					Many (comes bundled)				Minimal (only Python standard library)
Use Case	REST APIs, microservices		Large, database-driven web applications		Small web applications, APIs
Community	Medium					Large						Medium

======================================================================================================================================

Unit II: Introduction to Django Framework
Django is a high-level Python web framework that promotes rapid development and clean, pragmatic design. It is one of the most popular
frameworks for web development and comes with a "batteries-included" philosophy, meaning it provides many built-in features such as 
user authentication, database interaction, and URL routing.

----
Introduction to Django Framework
Django is a high-level Python web framework that enables developers to build robust, scalable, and secure web applications quickly 
and efficiently. It follows the Model-View-Template (MVT) architectural pattern, which simplifies the development process by 
separating the application's logic, presentation, and data handling.

Key Highlights of Django:

Batteries Included: Django comes with built-in features like an ORM (Object-Relational Mapping), authentication system, admin 
interface, form handling, and more.

Rapid Development: Its tools and features enable developers to go from concept to production faster than traditional methods.

Secure by Design: Django has in-built mechanisms to prevent common security issues like SQL injection, XSS, and CSRF attacks.

Scalability: Django is used by some of the largest websites in the world, including Instagram and Pinterest, proving its capability 
to handle high traffic and large-scale operations.

Open Source and Well-Supported: Being open source, Django has a vibrant community that ensures constant updates, comprehensive 
documentation, and plugins for extended functionality.

Why Choose Django?

Simplicity: The framework emphasizes keeping things straightforward and avoids unnecessary complexity.

Flexibility: Django can handle everything from simple websites to complex, enterprise-grade web applications.

Reusable Code: With its "Don’t Repeat Yourself" (DRY) principle, Django encourages reusability of code and reduces redundancy.

Core Philosophy of Django:

Loosely Coupled Components: Each part of Django works independently, allowing flexibility and modular development.
Less Code, More Productivity: Django reduces boilerplate code and provides built-in tools for common tasks.

Community Support: Django is backed by a strong community of developers who contribute to its plugins, documentation, and features.

By mastering Django, developers can efficiently create feature-rich web applications while focusing on writing clean and maintainable 
code

Understanding Django Environment
Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. To work with Django, you 
need to set up a proper development environment. Here’s an outline of the essential steps to understand and set up the Django 
environment:

Setting Up Django Environment
Install Python: Django is a Python-based framework, so Python needs to be installed first. It's recommended to use Python 3.x.

Check if Python is installed:
python --version

Install Django:

After installing Python, you can install Django using pip, the Python package manager.

Install Django:
pip install django

Verify the installation:
django-admin --version

Virtual Environment (Optional but Recommended):

Using a virtual environment ensures that your project dependencies are isolated from other projects. To create a virtual environment:

Install virtualenv:
pip install virtualenv

Create a virtual environment:
virtualenv venv

Activate the virtual environment:

On Windows:
.\venv\Scripts\activate

Create a Django Project:

Once your environment is set up, you can create your first Django project. In the terminal, run the following command to create a 
project:

Create a Django project:
django-admin startproject my_project_name

This command creates a directory structure with the necessary files to begin development.

Run the Development Server:

Navigate to your project directory and start the Django development server:

Start the development server:
cd my_project_name
python manage.py runserver

Visit http://127.0.0.1:8000/ in your web browser, and you should see the default Django welcome page.

Understanding Django Project Structure:

Once you create a Django project, you'll see the following directory structure:

manage.py: A command-line utility that helps you manage your Django project.
myproject/: The main project folder.
settings.py: The configuration file where you define settings like database configuration, middleware, installed apps, etc.
urls.py: The URL routing configuration.
wsgi.py: WSGI configuration for deploying the project.
asgi.py: ASGI configuration (for asynchronous servers).

simple steps:
------------
Python: Install and verify Python first.
Virtual Environment: Optional but a good practice.
Install Django: Using pip for installation.
Create a Project: Use django-admin startproject.
Development Server: Use python manage.py runserver to launch the local server.
Understanding the Django environment is the first step toward building dynamic web applications. Once your environment is set up, 
you can proceed with building applications within the project.

Features of Django Framework
Django is known for its simplicity and rapid development. Here are some of its key features:

MTV Architecture:

Django follows the Model-Template-View (MTV) architecture, which is similar to the traditional MVC (Model-View-Controller) 
architecture but with a few tweaks:
Model: Represents the data structure, defining how the data is stored and handled (e.g., tables in a database).
Template: Represents the user interface (UI), which is typically HTML with Django Template Language (DTL) for dynamic content 
rendering.
View: Handles the logic and processes user requests. Views handle URLs, return responses, and interact with models.
Automatic Admin Interface: Django comes with a built-in, customizable admin interface. After defining models, Django automatically 
generates an admin dashboard to manage content and interact with your database. This saves a lot of development time.

Security Features: Django is built with security in mind, and it provides several built-in features to prevent common web 
vulnerabilities:

SQL Injection Protection: Django’s ORM automatically escapes queries, preventing SQL injection.
Cross-Site Scripting (XSS) Protection: Automatic escaping of user input to prevent XSS.
Cross-Site Request Forgery (CSRF) Protection: Built-in middleware to prevent CSRF attacks.
Clickjacking Protection: Django includes protections to prevent clickjacking.
Object-Relational Mapping (ORM): Django provides a powerful ORM that allows developers to interact with databases using Python code 
instead of raw SQL. It abstracts database operations and provides high-level query-building functions.

URL Routing: Django uses URL routing to map incoming requests to views based on the URL pattern. URL patterns are defined in urls.py, 
allowing for clean and readable URLs, which are essential for SEO.

Scalability: Django is scalable and can be used for both small and large-scale applications. It supports caching, load balancing, and 
is compatible with many databases and middleware tools.

Fast Development: Django promotes rapid development by offering an extensive set of built-in tools. This includes built-in support 
for authentication, forms, file uploads, and more, so developers don’t need to reinvent the wheel.

Internationalization and Localization: Django supports internationalization (i18n) and localization (l10n), making it easy to develop 
applications that support multiple languages, currencies, and time zones.

REST Framework (Django REST Framework): For API development, Django provides an optional but powerful REST framework (DRF). DRF helps 
in building web APIs with ease, offering features like serialization, authentication, and view sets.

Community and Documentation: Django has an active community, and its documentation is comprehensive, making it easy for developers to 
learn, troubleshoot, and stay up to date.

Django follows the MTV (Model-Template-View) architecture, which organizes code in a way that separates concerns, making it easier to 
maintain, scale, and test.

Key Components of Django Architecture:
Model:

The Model represents the data structure of the application. It interacts with the database and defines the structure of the 
application’s data.
Django models are Python classes that inherit from django.db.models.Model.
Models define fields (e.g., CharField, IntegerField) and behaviors for the data.
Django uses its ORM (Object-Relational Mapping) to convert models into SQL queries, providing an abstraction layer over the database.

models.py
---------
from django.db import models

class Student(models.Model):
    name = models.CharField(max_length=100)
    age = models.IntegerField()
    grade = models.CharField(max_length=2)


Template:

The Template is responsible for rendering the HTML pages of the application. It contains the structure of the page, combined with 
dynamic data passed from the view.
Django uses its own templating engine (Django Template Language, or DTL), which allows embedding Python code inside HTML tags using 
{{ }} for variables and {% %} for control structures.
Templates are stored in the templates directory.

.html file
<h1>{{ student.name }}</h1>
<p>Age: {{ student.age }}</p>
<p>Grade: {{ student.grade }}</p>

View:

The View in Django is the business logic layer that processes user requests and returns appropriate responses.
A view receives input from a user, processes it (e.g., interacts with models), and returns a response (usually rendered HTML or JSON).
Views can be written as functions or class-based views. In the case of class-based views (CBVs), Django provides a set of reusable 
views for common tasks (e.g., listing records, creating entries).
Views can return HttpResponse objects or render templates.

views.py
from django.shortcuts import render
from .models import Student

def student_detail(request, student_id):
    student = Student.objects.get(id=student_id)
    return render(request, 'student_detail.html', {'student': student})

URL Dispatcher (URLconf):

The URL dispatcher is the part of Django that handles mapping URLs to views. This is defined in the urls.py file, where URL patterns 
are linked to specific views.
The URL dispatcher uses regular expressions to match incoming request URLs with a view.
Example (URLconf):

urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('student/<int:student_id>/', views.student_detail, name='student_detail'),
]

Django Middleware:

Middleware is a lightweight, low-level plugin system for globally altering Django’s input or output. It processes requests before they
reach the view and responses before they are sent to the client.
Common middleware includes authentication, session management, CSRF protection, and more.

dmin Interface:

Django provides an automatic admin interface to manage models through the browser.
Admin is configured by registering models in the admin.py file, which allows administrators to easily create, update, or delete data.
Example (admin registration):

admin.py
from django.contrib import admin
from .models import Student

admin.site.register(Student)

simple steps:
Model: Represents and manipulates data, interacts with the database.
Template: Renders the user interface and displays dynamic content.
View: Handles user input, interacts with the model, and returns a response (often a template).
URLconf: Maps URLs to views.
Middleware: Provides hooks for processing requests and responses globally.
Admin Interface: Built-in tool to manage the application’s data.
By dividing the architecture into clear layers, Django follows the best practices of separation of concerns, making development and 
maintenance easier.

MVC (Model-View-Controller) vs. MTV (Model-Template-View) in Django
Both MVC and MTV are software design patterns used to separate the concerns of an application into different components. While they 
share similarities, Django adopts the MTV pattern, which is slightly different from the traditional MVC pattern. Let's break down the 
two patterns and understand how they relate to each other.

MVC (Model-View-Controller) Architecture
The MVC pattern divides an application into three interconnected components:

Model:

Represents the data layer of the application.
The model is responsible for managing the data, logic, and rules of the application (e.g., interacting with the database).
Example: A Student model that defines the structure of a student, such as name, age, and grade.

View:

Represents the user interface (UI) layer.
The view displays the data from the model to the user and takes input from the user.
Example: An HTML page that displays student information to the user.
Controller:

Represents the logic layer that acts as an intermediary between the model and the view.
The controller handles the user input, interacts with the model, and updates the view accordingly.
Example: A function that processes a form submission, retrieves data from the model, and updates the UI with new information.

Flow in MVC:
The user interacts with the view (UI).
The controller takes the user’s input and updates the model.
The model updates the data, and the controller updates the view.

MTV (Model-Template-View) in Django
Django follows the MTV architecture, which is a slight variation of MVC. While the general structure remains similar, the terminology used in Django differs:

Model (Same as in MVC):

Represents the data structure and interacts with the database.
Defines the data structure and behaviors.
Example: The Student model, which maps to a database table.
Template (Equivalent to the View in MVC):

Represents the presentation layer or user interface (UI) in Django.
A template is an HTML file that defines how the data should be presented. It is dynamically populated with data passed from the view.
Example: A Django HTML template that displays the student information on a webpage.
View (Equivalent to the Controller in MVC):

In Django, the view is the business logic layer.
The view is responsible for processing the user request, interacting with the model, and passing the data to the template for 
rendering.
Example: A Django view function that processes a form, fetches data from the Student model, and passes it to a template for rendering.
Flow in MTV:
The user makes a request, which is routed to a view.
The view processes the request, interacts with the model to fetch or modify data.
The view then passes the data to a template for rendering.
The template is returned as an HTTP response, which is displayed to the user.

Key Differences Between MVC and MTV

Feature			MVC									MTV
Model			Represents the data layer.						Represents the data layer.
View			Represents the UI (user interface).					Represents the presentation layer (UI).
Controller		Handles the logic and user input.					Handles business logic (view).
Template		N/A									Represents the UI rendering part (HTML, templates).
Role of View		The View in MVC is the UI layer, directly interacting with the user.	The View in Django (MTV) is the business logic layer (controller in MVC).
Role of Template	N/A									The Template in Django is responsible for rendering HTML (like the View in MVC, but more focused on display).

Why Django Uses MTV Instead of MVC?
While Django is conceptually very similar to MVC, the reason for using the term MTV lies in the distinction between the controller and
the view:

In Django, the view handles the business logic, not the user interface. Hence, Django’s view corresponds more closely to the 
controller in the traditional MVC architecture.
The template in Django is the part that manages the presentation (UI), which is why it corresponds to the view in MVC.
Django’s terminology (MTV) better reflects the structure of the framework: views handling logic, templates rendering data, and models 
interacting with the database.

simple info:
MVC is a common architectural pattern that uses Model, View, and Controller.
MTV is Django's variant of MVC, where the Model is the same, the Template handles the UI (similar to the View in MVC), and the View 
handles the business logic (acting as the Controller in MVC).
Django’s MTV structure makes it easier to separate concerns and allows for a more streamlined workflow in web development.

URLs and Views in Django
In Django, URLs and Views are critical components that determine how your web application responds to user requests. Understanding how
Django handles URLs and views will help you structure your web application and route requests efficiently.

URLs in Django
The URLconf (URL configuration) in Django is responsible for mapping user requests (URLs) to appropriate views. The URLs are defined 
in a urls.py file, and Django uses this to determine which view should handle a specific request.

URL Patterns in Django:
Basic URL Patterns: URL patterns are defined in the urlpatterns list in urls.py. Each URL pattern maps a URL string to a specific 
view function.

urls.py
from django.contrib import admin
from django.urls import path, include
from firstapp import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', views.retrieve_view),
    path('insert/', views.insert_view),
    path('delete/<int:id>', views.delete_view),
    path('update/<int:id>', views.update_view),
]

URL Variables: Django allows you to capture dynamic parts of a URL using URL parameters. These can be captured using angle brackets 
< >.

In this example, <int:id> captures an integer value from the URL (e.g., update/123/), which is passed as an argument to the 
update_view.

Including URLconf from Other Apps: In a Django project, multiple apps may exist. You can include the URLs of other apps into your 
main project URLconf by using include().

# project's urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('app/', include('app_name.urls')),  # Include the URLs from 'app_name'
]

URL Named Patterns: Django allows you to name your URL patterns. Named URLs make it easier to reference URLs in your templates and 
views.

Example (Template usage):
<!-- In an HTML template -->
<a href="{% url 'home' %}">Home</a>

Views in Django
A view in Django is a function (or class) that receives web requests and returns web responses. Views are responsible for executing 
the business logic and determining what content is returned to the user.

Types of Views:
Function-based Views (FBVs): A function-based view is a Python function that receives an HTTP request and returns an HTTP response.

Example of Function-based View:
views.py
--------
from django.shortcuts import render,redirect
from firstapp.models import Employee
from firstapp.forms import EmployeeForm


# Create your views here
def retrieve_view(request):
    emp_list=Employee.objects.all()

    return render(request,'testapp/logout.html',{'emp_list':emp_list})

def insert_view(request):
    form=EmployeeForm()
    if request.method== 'POST':
        form=EmployeeForm(request.POST)
        if form.is_valid():
            form.save()
        return redirect('/')
    return render(request,'testapp/politics.html',{'form':form})

def delete_view(request,id):
    employee=Employee.objects.get(id=id)
    employee.delete()
    return redirect('/')

def update_view(request,id):
    employee=Employee.objects.get(id=id)
    form=EmployeeForm(instance=employee)
    if request.method=='POST':
        form=EmployeeForm(request.POST,instance=employee)
        if form.is_valid():
            form.save()
        return redirect('/')
    return render(request,'testapp/cloud.html',{'form':form})

request: An HttpRequest object representing the user’s request.
render(): A shortcut function that combines a template and context data and returns an HttpResponse.

Class-based Views (CBVs): Class-based views provide a more organized and reusable approach to writing views, especially when dealing 
with common web patterns like listing, creating, updating, or deleting objects.

Example of Class-based View:
# views.py
from django.views.generic import TemplateView

class HomeView(TemplateView):
    template_name = 'home.html'

class AboutView(TemplateView):
    template_name = 'about.html'

In this case, TemplateView is a generic view that renders a template. Class-based views are highly extendable, allowing developers to 
create views with more advanced functionality.

Views and HTTP Responses: Views return different types of responses, most commonly:

HttpResponse: A simple response.
JsonResponse: For returning JSON data (commonly used for APIs).
RedirectResponse: For redirecting users to another URL.

Example (HttpResponse):
from django.shortcuts import render,redirect
from firstapp.models import Employee
from firstapp.forms import EmployeeForm


# Create your views here
def retrieve_view(request):
    emp_list=Employee.objects.all()

Example (JsonResponse):
from django.http import JsonResponse

def json_view(request):
    data = {'name': 'John', 'age': 30}
    return JsonResponse(data)

How URLs and Views Work Together
When a user makes a request to a Django application, Django looks at the request URL, searches through the urls.py patterns, and finds
the view function or class associated with that URL. The view then processes the request, potentially querying the database or 
performing other logic, and returns a response.

Example flow:

The user visits http://127.0.0.1:8000/.
Django looks at urls.py and finds the pattern path('', views.retrieve_view).
The home view is called, which renders the testapp/logout.html template with the provided context.
The generated HTML is returned to the user as the response.

Best Practices for URLs and Views
Use Descriptive URL Patterns:

URLs should be descriptive and reflect the content they represent. For example, use update/<int:id>/ rather than page/1/ to indicate 
the student's profile.
Keep URL Patterns Organized:

If your project grows, split the urls.py into separate files for each app to keep it organized.
Use include() to include URLs from other apps into the main URLconf.
Avoid Hardcoding URLs:

Always use named URLs or the {% url %} tag in templates to generate URLs dynamically.
Use Class-based Views for Common Patterns:

Django provides many built-in class-based views (CBVs) for common patterns like displaying lists, handling forms, and CRUD operations.
CBVs can save time and make your views more reusable.

URLs in Django map user requests to views. They are defined in urls.py using the path() function and can include dynamic parts like 
URL parameters.
Views are functions or classes that process user requests and return responses, usually by rendering templates.
You can choose between function-based views (FBVs) or class-based views (CBVs) depending on the complexity of your application.
The URLconf and Views together form the backbone of routing in Django, handling the flow of user requests to specific functionality.

